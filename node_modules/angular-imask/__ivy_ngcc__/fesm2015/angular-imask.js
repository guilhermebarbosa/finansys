import { Injectable, ɵɵdefineInjectable, forwardRef, EventEmitter, Directive, ElementRef, Renderer2, Optional, Inject, Input, Output, Pipe, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import IMask, { pipe } from 'imask';
import * as ɵngcc0 from '@angular/core';
export { PIPE_TYPE, pipe } from 'imask';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class IMaskFactory {
}
IMaskFactory.ɵfac = function IMaskFactory_Factory(t) { return new (t || IMaskFactory)(); };
IMaskFactory.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IMaskFactory, factory: IMaskFactory.ɵfac, providedIn: "root" });
/** @nocollapse */ IMaskFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function IMaskFactory_Factory() { return new IMaskFactory(); }, token: IMaskFactory, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IMaskFactory, [{
        type: Injectable,
        args: [{ providedIn: "root" }]
    }], null, null); })();
if (false) {
    /**
     * @abstract
     * @template Opts
     * @param {?} el
     * @param {?} opts
     * @return {?}
     */
    IMaskFactory.prototype.create = function (el, opts) { };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => IMaskDirective)),
    multi: true
};
/** @type {?} */
const DEFAULT_IMASK_ELEMENT = (/**
 * @param {?} elementRef
 * @return {?}
 */
(elementRef) => elementRef.nativeElement);
const ɵ0 = DEFAULT_IMASK_ELEMENT;
/**
 * @template Opts
 */
class IMaskDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     * @param {?} _factory
     * @param {?} _compositionMode
     */
    constructor(_elementRef, _renderer, _factory, _compositionMode) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._factory = _factory;
        this._compositionMode = _compositionMode;
        // init here to support AOT (TODO may be will work with ng-packgr - need to check)
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
        this.onChange = (/**
         * @return {?}
         */
        () => { });
        this.imaskElement = DEFAULT_IMASK_ELEMENT;
        this.accept = new EventEmitter();
        this.complete = new EventEmitter();
        this._viewInitialized = false;
        this._composing = false;
        this._writing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !this._isAndroid();
        }
    }
    /**
     * @return {?}
     */
    get element() {
        return this.imaskElement(this._elementRef, this);
    }
    /**
     * @return {?}
     */
    get maskValue() {
        if (!this.maskRef)
            return this.element.value;
        if (this.unmask === 'typed')
            return this.maskRef.typedValue;
        if (this.unmask)
            return this.maskRef.unmaskedValue;
        return this.maskRef.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maskValue(value) {
        if (this.maskRef) {
            if (this.unmask === 'typed')
                this.maskRef.typedValue = value;
            else if (this.unmask)
                this.maskRef.unmaskedValue = value;
            else
                this.maskRef.value = value;
        }
        else {
            this._renderer.setProperty(this.element, 'value', value);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.imask)
            this.initMask();
        this._viewInitialized = true;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.elementRef && !this.imaskElement)
            this.imaskElement = DEFAULT_IMASK_ELEMENT;
        if (!changes.imask || !this._viewInitialized)
            return;
        if (this.imask) {
            if (this.maskRef)
                this.maskRef.updateOptions(this.imask);
            else {
                this.initMask();
                this.onChange(this.maskValue);
            }
        }
        else {
            this.destroyMask();
        }
    }
    /**
     * @return {?}
     */
    destroyMask() {
        if (this.maskRef) {
            this.maskRef.destroy();
            delete this.maskRef;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyMask();
        this.accept.complete();
        this.complete.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    beginWrite(value) {
        this._writing = true;
        this._writingValue = value;
    }
    /**
     * @return {?}
     */
    endWrite() {
        this._writing = false;
        return this._writingValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        value = value == null ? '' : value;
        if (this.maskRef) {
            this.beginWrite(value);
            if (this.maskValue !== value ||
                // handle cases like Number('') === 0,
                // for details see https://github.com/uNmAnNeR/imaskjs/issues/134
                (typeof value !== 'string' && this.maskRef.value === '') &&
                    !this.maskRef.el.isActive) {
                this.maskValue = value;
            }
        }
        else {
            this._renderer.setProperty(this.element, 'value', value);
        }
    }
    /**
     * @return {?}
     */
    _onAccept() {
        /** @type {?} */
        const value = this.maskValue;
        // if value was not changed during writing don't fire events
        // for details see https://github.com/uNmAnNeR/imaskjs/issues/136
        if (this._writing && value === this.endWrite())
            return;
        this.onChange(value);
        this.accept.emit(value);
    }
    /**
     * @return {?}
     */
    _onComplete() {
        this.complete.emit(this.maskValue);
    }
    /**
     * @private
     * @return {?}
     */
    initMask() {
        this.maskRef = this._factory.create(this.element, (/** @type {?} */ (this.imask)))
            .on('accept', this._onAccept.bind(this))
            .on('complete', this._onComplete.bind(this));
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this.element, 'disabled', isDisabled);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) { this.onChange = fn; }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { this.onTouched = fn; }
    /**
     * @param {?} value
     * @return {?}
     */
    _handleInput(value) {
        // if mask is attached all input goes throw mask
        if (this.maskRef)
            return;
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this.onChange(value);
        }
    }
    /**
     * @return {?}
     */
    _compositionStart() { this._composing = true; }
    /**
     * @param {?} value
     * @return {?}
     */
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
    /**
     * @private
     * @return {?}
     */
    _isAndroid() {
        return /android (\d+)/.test(navigator.userAgent.toLowerCase());
    }
}
IMaskDirective.ɵfac = function IMaskDirective_Factory(t) { return new (t || IMaskDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(IMaskFactory), ɵngcc0.ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8)); };
IMaskDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IMaskDirective, selectors: [["", "imask", ""]], hostBindings: function IMaskDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function IMaskDirective_input_HostBindingHandler($event) { return ctx._handleInput($event.target.value); })("blur", function IMaskDirective_blur_HostBindingHandler() { return ctx.onTouched(); })("compositionstart", function IMaskDirective_compositionstart_HostBindingHandler() { return ctx._compositionStart(); })("compositionend", function IMaskDirective_compositionend_HostBindingHandler($event) { return ctx._compositionEnd($event.target.value); });
    } }, inputs: { imaskElement: "imaskElement", imask: "imask", unmask: "unmask" }, outputs: { accept: "accept", complete: "complete" }, features: [ɵngcc0.ɵɵProvidersFeature([MASKEDINPUT_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
IMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: IMaskFactory },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
IMaskDirective.propDecorators = {
    imask: [{ type: Input }],
    unmask: [{ type: Input }],
    imaskElement: [{ type: Input }],
    accept: [{ type: Output }],
    complete: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IMaskDirective, [{
        type: Directive,
        args: [{
                selector: '[imask]',
                host: {
                    '(input)': '_handleInput($event.target.value)',
                    '(blur)': 'onTouched()',
                    '(compositionstart)': '_compositionStart()',
                    '(compositionend)': '_compositionEnd($event.target.value)'
                },
                providers: [MASKEDINPUT_VALUE_ACCESSOR]
            }]
    }], function () { return [{ type: ElementRef }, { type: Renderer2 }, { type: IMaskFactory }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [COMPOSITION_BUFFER_MODE]
            }] }]; }, { imaskElement: [{
            type: Input
        }], accept: [{
            type: Output
        }], complete: [{
            type: Output
        }], imask: [{
            type: Input
        }], unmask: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    IMaskDirective.prototype.maskRef;
    /** @type {?} */
    IMaskDirective.prototype.onTouched;
    /** @type {?} */
    IMaskDirective.prototype.onChange;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._viewInitialized;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._composing;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._writingValue;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._writing;
    /** @type {?} */
    IMaskDirective.prototype.imask;
    /** @type {?} */
    IMaskDirective.prototype.unmask;
    /** @type {?} */
    IMaskDirective.prototype.imaskElement;
    /** @type {?} */
    IMaskDirective.prototype.accept;
    /** @type {?} */
    IMaskDirective.prototype.complete;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._factory;
    /**
     * @type {?}
     * @private
     */
    IMaskDirective.prototype._compositionMode;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Transforms value through mask
 * Takes mask and optionally `from` and `to` pipe types.
 * Usage:
 *   value | imask:MASK_OR_MASKED:opt_from:opt_to
 * Example:
 *   {{ 2 | imask:mask }}
*/
class IMaskPipe {
    /**
     * @param {...?} args
     * @return {?}
     */
    transform(...args) {
        return pipe(...args);
    }
}
IMaskPipe.ɵfac = function IMaskPipe_Factory(t) { return new (t || IMaskPipe)(); };
IMaskPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "imask", type: IMaskPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IMaskPipe, [{
        type: Pipe,
        args: [{ name: 'imask' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultImaskFactory {
    /**
     * @template Opts
     * @param {?} el
     * @param {?} opts
     * @return {?}
     */
    create(el, opts) {
        return IMask(el, opts);
    }
}
DefaultImaskFactory.ɵfac = function DefaultImaskFactory_Factory(t) { return new (t || DefaultImaskFactory)(); };
DefaultImaskFactory.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DefaultImaskFactory, factory: DefaultImaskFactory.ɵfac, providedIn: 'root' });
/** @nocollapse */ DefaultImaskFactory.ngInjectableDef = ɵɵdefineInjectable({ factory: function DefaultImaskFactory_Factory() { return new DefaultImaskFactory(); }, token: DefaultImaskFactory, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DefaultImaskFactory, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IMaskDirectiveModule {
}
IMaskDirectiveModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IMaskDirectiveModule });
IMaskDirectiveModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IMaskDirectiveModule_Factory(t) { return new (t || IMaskDirectiveModule)(); }, providers: [{ provide: IMaskFactory, useClass: DefaultImaskFactory }], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IMaskDirectiveModule, { declarations: function () { return [IMaskDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IMaskDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IMaskDirectiveModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [IMaskDirective],
                providers: [{ provide: IMaskFactory, useClass: DefaultImaskFactory }],
                exports: [IMaskDirective]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IMaskModule {
}
IMaskModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IMaskModule });
IMaskModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IMaskModule_Factory(t) { return new (t || IMaskModule)(); }, imports: [[CommonModule, IMaskDirectiveModule], IMaskDirectiveModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IMaskModule, { declarations: function () { return [IMaskPipe]; }, imports: function () { return [CommonModule, IMaskDirectiveModule]; }, exports: function () { return [IMaskPipe, IMaskDirectiveModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IMaskModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, IMaskDirectiveModule],
                declarations: [IMaskPipe],
                exports: [IMaskPipe, IMaskDirectiveModule]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IMaskDirective, IMaskDirectiveModule, IMaskFactory, IMaskModule, IMaskPipe, MASKEDINPUT_VALUE_ACCESSOR, DefaultImaskFactory as ɵa };

//# sourceMappingURL=angular-imask.js.map