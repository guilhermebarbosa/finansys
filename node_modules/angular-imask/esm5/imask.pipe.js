var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Pipe } from '@angular/core';
import { pipe } from 'imask';
export { PIPE_TYPE, pipe } from 'imask';
/*
 * Transforms value through mask
 * Takes mask and optionally `from` and `to` pipe types.
 * Usage:
 *   value | imask:MASK_OR_MASKED:opt_from:opt_to
 * Example:
 *   {{ 2 | imask:mask }}
*/
var IMaskPipe = /** @class */ (function () {
    function IMaskPipe() {
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    IMaskPipe.prototype.transform = /**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return pipe.apply(void 0, __spread(args));
    };
    IMaskPipe.decorators = [
        { type: Pipe, args: [{ name: 'imask' },] }
    ];
    return IMaskPipe;
}());
export { IMaskPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hc2sucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItaW1hc2svIiwic291cmNlcyI6WyJpbWFzay5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRXBELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFDN0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxPQUFPLENBQUM7Ozs7Ozs7OztBQVd4QztJQUFBO0lBS0EsQ0FBQzs7Ozs7SUFIQyw2QkFBUzs7OztJQUFUO1FBQVcsY0FBZ0M7YUFBaEMsVUFBZ0MsRUFBaEMscUJBQWdDLEVBQWhDLElBQWdDO1lBQWhDLHlCQUFnQzs7UUFDekMsT0FBTyxJQUFJLHdCQUFJLElBQUksR0FBRTtJQUN2QixDQUFDOztnQkFKRixJQUFJLFNBQUMsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFDOztJQUtyQixnQkFBQztDQUFBLEFBTEQsSUFLQztTQUpZLFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnaW1hc2snO1xyXG5leHBvcnQgeyBQSVBFX1RZUEUsIHBpcGUgfSBmcm9tICdpbWFzayc7XHJcblxyXG5cclxuLypcclxuICogVHJhbnNmb3JtcyB2YWx1ZSB0aHJvdWdoIG1hc2tcclxuICogVGFrZXMgbWFzayBhbmQgb3B0aW9uYWxseSBgZnJvbWAgYW5kIGB0b2AgcGlwZSB0eXBlcy5cclxuICogVXNhZ2U6XHJcbiAqICAgdmFsdWUgfCBpbWFzazpNQVNLX09SX01BU0tFRDpvcHRfZnJvbTpvcHRfdG9cclxuICogRXhhbXBsZTpcclxuICogICB7eyAyIHwgaW1hc2s6bWFzayB9fVxyXG4qL1xyXG5AUGlwZSh7bmFtZTogJ2ltYXNrJ30pXHJcbmV4cG9ydCBjbGFzcyBJTWFza1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICB0cmFuc2Zvcm0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHBpcGU+KTogUmV0dXJuVHlwZTx0eXBlb2YgcGlwZT4ge1xyXG4gICAgcmV0dXJuIHBpcGUoLi4uYXJncyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==